package com.aura.engine.module.shell;

import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.util.HashMap;
import java.util.Map;

import com.aura.base.utils.Validate;
import com.aura.client.AuraClient;
import com.aura.engine.AuraEngine;
import com.aura.engine.AuraScreen;
import com.aura.engine.event.EPEventInputKey;
import com.aura.engine.event.EPEventInputMouse;
import com.aura.engine.inputMap.EPMapCE;
import com.aura.engine.inputMap.mouse.EPMouseMapCM;
import com.aura.engine.module.AuraEngineModule;

public abstract class EMShell extends AuraEngineModule {
	private final int keyAction;
	
	private boolean visible;
	private boolean pinned;
	
	private final Map<GridBagConstraints, MObject> objects;
	private final MObject[][] objectTab;
	private final int maxXCell, maxYCell;
	
	private int maxXDecal, maxYDecal;
	
	public EMShell(AuraClient aura, AuraScreen screen, AuraEngine scene, int keyAction) {
		super(aura, screen, scene);
		this.keyAction = keyAction;
		this.objects = new HashMap<GridBagConstraints, MObject>();
		this.pinned = false;
		
		initialize();
		
		int minX = 0;
		int minY = 0;
		for (final GridBagConstraints gbc: getObjects().keySet()) {
			if (gbc != null) {
				if (gbc.gridx > minX) 
					minX = gbc.gridx;
				if (gbc.gridy > minY) 
					minY = gbc.gridy;
			}
		}
		
		maxXCell = minX+1;
		maxYCell = minY+1;
		
		objectTab = new MObject[maxXCell][maxYCell];
		for (final GridBagConstraints gbc: getObjects().keySet()) {
			if (gbc != null && (gbc.gridx >= 0 && gbc.gridy >= 0))
				objectTab[gbc.gridx][gbc.gridy] = getObjects().get(gbc);
		}
	}
	
	public abstract int getX();
	public abstract int getY();
	public abstract int getWidth();
	public abstract int getHeight();
	
	public boolean isVisible() {
		return visible;
	}
	public boolean isPinned() {
		return pinned;
	}
	protected void setPinned(boolean pinned) {
		this.pinned = pinned;
	}
	
	private synchronized Map<GridBagConstraints, MObject> getObjects() {
		return objects;
	}
	public void attach(GridBagConstraints gbc, MObject object) {
		Validate.notNull(gbc);
		Validate.notNull(object);
		if (gbc.gridx < 0 || gbc.gridy < 0) {
			object.setVisible(false);
		}
		getObjects().put(gbc, object);
	}

	public abstract void initialize();
	
	@Override 
	public void doUpdate() {
		if (!isVisible() && !isPinned()) return;
		
		maxXDecal = (getWidth()) / maxXCell; 
		maxYDecal = (getHeight() - getHeaderYDecal()) / maxYCell;
		
		implDoUpdate();
	}
	public abstract void implDoUpdate();
	
	public abstract int getHeaderYDecal();
	
	@Override 
	public void doDraw(Graphics2D g) {
		if (!isVisible() && !isPinned()) return;
		implDoDraw(g);
		
		for (int y=0; y<maxYCell;y++) {
			for (int x=0; x<maxXCell;x++) {
				MObject o = objectTab[x][y];
				if (o != null && o.isVisible()) {
					int xPos = getX() + (x * maxXDecal) + (maxXDecal / 2) - (o.getW() / 2);
					int yPos = getY() + (y * maxYDecal) + (maxYDecal / 2) - (o.getH() / 2) + getHeaderYDecal();
					o.draw(g, xPos, yPos);
				}
			}
		}
	}
	public abstract void implDoDraw(Graphics2D g);
	public abstract void implDoDrawDebug();
	
	@Override 
	public void doKeyReleased(EPEventInputKey e, EPMapCE map) {
		if (map != null && map.getId() == keyAction) {
			show(!visible);
			return;
		}
	}
	public void show(boolean lShow) {
		if (!lShow) {
			visible = false;
			pinned = false;
			releaseFocus();
		} else {
			pinned = false;
			if (gainFocus()) {
				visible = true;
			}
		}
	}
	public void pin(boolean pin) {
		if (pin) {
			pinned = true;
			releaseFocus();
		} else {
			if (gainFocus())
				pinned = false;
		}
	}

	@Override 
	public void doMouseReleased(EPEventInputMouse e, EPMapCE map) {
		if (!isVisible() && !isPinned()) return;
		if (map != null && map.getId() == EPMouseMapCM.SELECT) {
			for (GridBagConstraints gbc: getObjects().keySet()) {
				MObject mo = getObjects().get(gbc);
				if (mo != null) {
					if (mo.intersect(
							(int) e.getLocation().x, 
							(int) e.getLocation().y)) {
						mo.actionExecute();
					}
				}
			}
		}
	}
	
	@Override 
	public void doKeyPressed(EPEventInputKey e, EPMapCE map) {
		if (!isVisible() && !isPinned()) return;
	}
	@Override 
	public void doMousePressed(EPEventInputMouse e, EPMapCE map) {
		if (!isVisible() && !isPinned()) return;
	}
	
	/**
	 * CREATE GBC RAPIDE
	 */
	
	private int fakeXGbc = -1;
	private int getFakeXGbc() {
		int temp = fakeXGbc;
		fakeXGbc -= 1;
		return temp;
	}
	
	public GridBagConstraints createFakeGbc() {
		return createGbc(getFakeXGbc(), 0, false, 0);
	}
	
	public GridBagConstraints createGbc(int x, int y, boolean fill) {
		return createGbc(x, y, fill, 0);
	}
	
	public static GridBagConstraints createGbc(int x, int y, boolean fill, int gridwidth) {
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridx = x; gbc.gridy = y;
		gbc.fill = fill ? GridBagConstraints.HORIZONTAL : GridBagConstraints.NONE;
		gbc.weightx = fill ? 1 : 0;
		gbc.insets = new Insets(5, 5, 5, 5);
		gbc.anchor = GridBagConstraints.WEST;
		if (gridwidth > 0)
			gbc.gridwidth = gridwidth;
		return gbc;
	}
}